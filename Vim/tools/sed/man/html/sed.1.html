 <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>SED("1") manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
sed - manual page for sed version 4.1.4 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>k:Textproc<font size='+1'>d4.1.4<font size='+1'>d-4.1.4<font size='+1'>d<font size='+1'>d.exe</b>
[<i>OPTION</i>]... <i>{script-only-if-no-other-script} </i>[<i>input-file</i>]... </font>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
 is a stream
editor. A stream editor is used to perform basic text transformations on
an input stream (a file or input from a pipeline). While in some ways similar
to an editor which permits scripted edits (such as <i>ed</i>),  works by making
only one pass over the input(s), and is consequently more efficient. But
it is &rsquo;s ability to filter text in a pipeline which particularly distinguishes
it from other types of editors. <p>
<br>
 
<dl>

<dt><b>-n</b>, <b>--quiet</b>, <b>--silent</b> </dt>
<dd></dd>

<dt>suppress automatic printing of pattern space </dt>
<dd></dd>

<dt><b>-e</b> script,
<b>--expression</b>=<i>script</i> </dt>
<dd></dd>

<dt>add the script to the commands to be executed </dt>
<dd></dd>

<dt><b>-f</b> script-file,
<b>--file</b>=<i>script-file</i> </dt>
<dd></dd>

<dt>add the contents of script-file to the commands to be executed
</dt>
<dd></dd>

<dt><b>-i[SUFFIX]</b>, <b>--in-place</b>[=<i>SUFFIX</i>] </dt>
<dd></dd>

<dt>edit files in place (makes backup if extension
supplied) </dt>
<dd></dd>

<dt><b>-l</b> N, <b>--line-length</b>=<i>N</i> </dt>
<dd></dd>

<dt>specify the desired line-wrap length for the
&lsquo;l&rsquo; command </dt>
<dd></dd>

<dt><b>--posix</b> </dt>
<dd></dd>

<dt>disable all GNU extensions. </dt>
<dd></dd>

<dt><b>-r</b>, <b>--regexp-extended</b> </dt>
<dd></dd>

<dt>use extended
regular expressions in the script. </dt>
<dd></dd>

<dt><b>-s</b>, <b>--separate</b> </dt>
<dd></dd>

<dt>consider files as separate
rather than as a single continuous </dt>
<dd>long stream. </dd>

<dt><b>-u</b>, <b>--unbuffered</b> </dt>
<dd></dd>

<dt>load minimal
amounts of data from the input files and flush </dt>
<dd>the output buffers more
often </dd>

<dt><b>--help</b> </dt>
<dd>display this help and exit </dd>

<dt><b>--version</b> </dt>
<dd>output version information
and exit </dd>

<dt><b>-B</b>, <b>--binary</b> </dt>
<dd>use binary read and writes. </dd>
</dl>
<p>
<br>
 If no <b>-e</b>, <b>--expression</b>, <b>-f</b>, or <b>--file</b> option is given, then the first non-option
argument is taken as the sed script to interpret.  All remaining arguments
are names of input files; if no input files are specified, then the standard
input is read. <p>
<br>
 E-mail bug reports to: bonzini@gnu.org . Be sure to include the word &lsquo;&lsquo;sed&rsquo;&rsquo;
somewhere in the &lsquo;&lsquo;Subject:&rsquo;&rsquo; field. 
<h2><a name='sect3' href='#toc3'>Command Synopsis</a></h2>
This is just a brief synopsis
of  commands to serve as a reminder to those who already know ; other documentation
(such as the texinfo document) must be consulted for fuller descriptions.
Zero-address &lsquo;&lsquo;commands&rsquo;&rsquo; 
<dl>

<dt>:&nbsp;<i>label</i> </dt>
<dd>Label for <b>b</b> and <b>t</b> commands. </dd>

<dt>#<i>comment</i> </dt>
<dd>The comment
extends until the next newline (or the end of a <b>-e</b> script fragment). </dd>

<dt>} </dt>
<dd>The
closing bracket of a { } block. Zero- or One- address commands </dd>

<dt>= </dt>
<dd>Print the
current line number. </dd>

<dt>a \ </dt>
<dd></dd>

<dt><i>text</i> </dt>
<dd>Append <i>text</i>, which has each embedded newline
preceded by a backslash. </dd>

<dt>i \ </dt>
<dd></dd>

<dt><i>text</i> </dt>
<dd>Insert <i>text</i>, which has each embedded newline
preceded by a backslash. </dd>

<dt>q </dt>
<dd>Immediately quit the  script without processing
any more input, except that if auto-print is not disabled the current pattern
space will be printed. </dd>

<dt>Q </dt>
<dd>Immediately quit the  script without processing
any more input. </dd>

<dt>r&nbsp;<i>filename</i> </dt>
<dd>Append text read from <i>filename</i>. </dd>

<dt>R&nbsp;<i>filename</i> </dt>
<dd>Append
a line read from <i>filename</i>. Commands which accept address ranges </dd>

<dt>{ </dt>
<dd>Begin
a block of commands (end with a }). </dd>

<dt>b&nbsp;<i>label</i> </dt>
<dd>Branch to <i>label</i>; if <i>label</i> is
omitted, branch to end of script. </dd>

<dt>t&nbsp;<i>label</i> </dt>
<dd>If a s/// has done a successful
substitution since the last input line was read and since the last t or
T command, then branch to <i>label</i>; if <i>label</i> is omitted, branch to end of
script. </dd>

<dt>T&nbsp;<i>label</i> </dt>
<dd>If no s/// has done a successful substitution since the last
input line was read and since the last t or T command, then branch to <i>label</i>;
if <i>label</i> is omitted, branch to end of script. </dd>

<dt>c \ </dt>
<dd></dd>

<dt><i>text</i> </dt>
<dd>Replace the selected
lines with <i>text</i>, which has each embedded newline preceded by a backslash.
</dd>

<dt>d </dt>
<dd>Delete pattern space. Start next cycle. </dd>

<dt>D </dt>
<dd>Delete up to the first embedded
newline in the pattern space. Start next cycle, but skip reading from the
input if there is still data in the pattern space. </dd>

<dt>h H </dt>
<dd>Copy/append pattern
space to hold space. </dd>

<dt>g G </dt>
<dd>Copy/append hold space to pattern space. </dd>

<dt>x </dt>
<dd>Exchange
the contents of the hold and pattern spaces. </dd>

<dt>l </dt>
<dd>List out the current line
in a &lsquo;&lsquo;visually unambiguous&rsquo;&rsquo; form. </dd>

<dt>n N </dt>
<dd>Read/append the next line of input into
the pattern space. </dd>

<dt>p </dt>
<dd>Print the current pattern space. </dd>

<dt>P </dt>
<dd>Print up to the first
embedded newline of the current pattern space. </dd>

<dt>s/<i>regexp</i>/<i>replacement</i>/<i></i> </dt>
<dd>Attempt
to match <i>regexp</i> against the pattern space. If successful, replace that portion
matched with <i>replacement</i>. The <i>replacement</i> may contain the special character
<b>&amp;</b> to refer to that portion of the pattern space which matched, and the special
escapes \1 through \9 to refer to the corresponding matching sub-expressions
in the <i>regexp</i>. </dd>

<dt>w&nbsp;<i>filename</i> </dt>
<dd>Write the current pattern space to <i>filename</i>. </dd>

<dt>W&nbsp;<i>filename</i>
</dt>
<dd>Write the first line of the current pattern space to <i>filename</i>. </dd>

<dt>y/<i>source</i>/<i>dest</i>/<i></i>
</dt>
<dd>Transliterate the characters in the pattern space which appear in <i>source</i>
to the corresponding character in <i>dest</i>. </dd>
</dl>
Addresses  commands can be given
with no addresses, in which case the command will be executed for all input
lines; with one address, in which case the command will only be executed
for input lines which match that address; or with two addresses, in which
case the command will be executed for all input lines which match the inclusive
range of lines starting from the first address and continuing to the second
address. Three things to note about address ranges: the syntax is <i>addr1</i>,<i>addr2</i>
(i.e., the addresses are separated by a comma); the line which <i>addr1</i> matched
will always be accepted, even if <i>addr2</i> selects an earlier line; and if
<i>addr2</i> is a <i>regexp</i>, it will not be tested against the line that <i>addr1</i> matched.
<p>
After the address (or address-range), and before the command, a <b>!</b> may be
inserted, which specifies that the command shall only be executed if the
address (or address-range) does <b>not</b> match. <p>
The following address types are
supported: 
<dl>

<dt><i>number</i> </dt>
<dd>Match only the specified line <i>number</i>. </dd>

<dt><i>first</i>~<i>step</i> </dt>
<dd>Match
every <i>step</i>&rsquo;th line starting with line <i>first</i>. For example, &lsquo;&lsquo;sed -n 1~2p&rsquo;&rsquo; will
print all the odd-numbered lines in the input stream, and the address 2~5
will match every fifth line, starting with the second. (This is an extension.)
</dd>

<dt>$ </dt>
<dd>Match the last line. </dd>

<dt>/<i>regexp</i>/<i></i> </dt>
<dd>Match lines matching the regular expression
<i>regexp</i>. </dd>

<dt><b>\c</b><i>regexp</i><b>c</b> </dt>
<dd>Match lines matching the regular expression <i>regexp</i>. The
<b>c</b> may be any character. </dd>
</dl>
<p>
GNU  also supports some special 2-address forms:

<dl>

<dt>0,<i>addr2</i> </dt>
<dd>Start out in "matched first address" state, until <i>addr2</i> is found.
This is similar to 1,<i>addr2</i>,<i></i> except that if <i>addr2</i> matches the very first
line of input the 0,<i>addr2</i> form will be at the end of its range, whereas
the 1,<i>addr2</i> form will still be at the beginning of its range. </dd>

<dt><i>addr1</i>,+<i>N</i> </dt>
<dd>Will
match <i>addr1</i> and the <i>N</i> lines following <i>addr1</i>. </dd>

<dt><i>addr1</i>,~<i>N</i> </dt>
<dd>Will match <i>addr1</i> and
the lines following <i>addr1</i> until the next line whose input line number is
a multiple of <i>N</i>. </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Regular Expressions</a></h2>
POSIX.2 BREs <i>should</i> be supported, but
they aren&rsquo;t completely because of performance problems. The <b>\n</b> sequence in
a regular expression matches the newline character, and similarly for <b>\a</b>,
<b>\t</b>, and other sequences. 
<h2><a name='sect5' href='#toc5'>Bugs</a></h2>
<p>
E-mail bug reports to <b>bonzini@gnu.org</b>. Be sure
to include the word &lsquo;&lsquo;sed&rsquo;&rsquo; somewhere in the &lsquo;&lsquo;Subject:&rsquo;&rsquo; field. Also, please include
the output of &lsquo;&lsquo;sed --version&rsquo;&rsquo; in the body of your report if at all possible.

<h2><a name='sect6' href='#toc6'>Copyright</a></h2>
Copyright &copy; 2003 Free Software Foundation, Inc. <br>
This is free software; see the source for copying conditions.  There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE, to the extent permitted by law. 
<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='awk.1.html'><b>awk</b>(1)</a>
, <a href='ed.1.html'><b>ed</b>(1)</a>
, <a href='grep.1.html'><b>grep</b>(1)</a>
,
<a href='tr.1.html'><b>tr</b>(1)</a>
, <a href='perlre.1.html'><b>perlre</b>(1)</a>
, sed.info, any of various books on ,  the  FAQ (http://sed.sf.net/grabbag/tutorials/sedfaq.html),
<a href='http://sed.sf.net/grabbag/.'>http://sed.sf.net/grabbag/.</a>
 <p>
The full documentation for <b>sed</b> is maintained as
a Texinfo manual.  If the <b>info</b> and <b>sed</b> programs are properly installed at
your site, the command 
<dl>

<dt><b>info sed</b> </dt>
<dd></dd>
</dl>
<p>
should give you access to the complete
manual. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Command Synopsis</a></li>
<li><a name='toc4' href='#sect4'>Regular Expressions</a></li>
<li><a name='toc5' href='#sect5'>Bugs</a></li>
<li><a name='toc6' href='#sect6'>Copyright</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
</ul>
</body>
</html>
